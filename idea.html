<html>
<head>
	<script src="fabric.js"></script>
	<script src="jquery.js"></script>
    <script src="underscore-min.js"></script>
	<style>
canvas {
    border: 1px solid #ccc;
}
</style>
</head>
<body>
	<button id="btnZoomIn">ZoomIn</button> 
	<button id="btnZoomOut">ZoomOut</button> 
	<button id="btnResetZoom">Reset Zoom</button>
	<br/>
	<canvas id="floorDemoCanvas" width="800" height="800"></canvas>
</body>

<script>
var GRID_STEP_GRANULARITY = 25;
var scaledGridStep = 25;
var GRID_DIMENSIONS = 800;
var scaleFactorApplied = 1;
var currentCanvasScale = 1;
var SCALE_MULTIPLYING_FACTOR = 1.2;
var floorCanvas;

function initFloorCanvas()
{
    floorCanvas = new fabric.Canvas('floorDemoCanvas', { selection: false });

    fabric.Image.fromURL('floor.png', function(img) {
          
          // the image should react as a background image
          // it is added as an object so that it can get scaled when zoomed in
          img.hasControls = false;
          img.lockMovementX = true;
          img.lockMovementY = true;

          floorCanvas.add(img);

          // everything else needs to be added AFTER IMAGE else not visible

        // create grid
        var linesCount = GRID_DIMENSIONS / GRID_STEP_GRANULARITY;
        for (var lineIndex = 0; lineIndex < linesCount; lineIndex++) {
          floorCanvas.add(new fabric.Line([ lineIndex * GRID_STEP_GRANULARITY, 0, lineIndex * GRID_STEP_GRANULARITY, GRID_DIMENSIONS], { stroke: '#ccc', selectable: false }));
          floorCanvas.add(new fabric.Line([ 0, lineIndex * GRID_STEP_GRANULARITY, GRID_DIMENSIONS, lineIndex * GRID_STEP_GRANULARITY], { stroke: '#ccc', selectable: false }))
        }

        floorCanvas.add(new fabric.Rect({ 
          left: 100, 
          top: 100, 
          width: GRID_STEP_GRANULARITY, 
          height: GRID_STEP_GRANULARITY, 
          fill: '#faa', 
          originX: 'left', 
          originY: 'top',
            hasControls: false
        }));
    });

    // snap to grid
    floorCanvas.on('object:moving', function(options) {
        var gridFittedCoordinates = getScaledCellCoordinates(options.target.left, options.target.top);
        
      options.target.set({
        left: gridFittedCoordinates.left,
        top: gridFittedCoordinates.top
      });
    });

    $("#btnZoomIn").click(function(){
        zoomIn();
    });

    $("#btnZoomOut").click(function(){
        zoomOut();
    });

    $("#btnResetZoom").click(function(){
        resetZoom();
    });
}

function zoomIn() {
    applyScaleToGridAndObjects(SCALE_MULTIPLYING_FACTOR);
}

function zoomOut() {
    applyScaleToGridAndObjects(1/SCALE_MULTIPLYING_FACTOR);  
}

function resetZoom() {
    applyScaleToGridAndObjects(1/currentCanvasScale);

    currentCanvasScale = 1;
    scaleFactorApplied = 1;
}

function applyScaleToGridAndObjects(scaleValue)
{
    scaleFactorApplied = scaleValue;
    currentCanvasScale = currentCanvasScale * scaleValue;
    scaledGridStep = scaledGridStep * scaleValue;

    floorCanvas.setHeight(floorCanvas.getHeight() * scaleValue);
    floorCanvas.setWidth(floorCanvas.getWidth() * scaleValue);
    
    var objectsOnCanvas = floorCanvas.getObjects();

    _.each(objectsOnCanvas, function(object){

        object.scaleX = object.scaleX * scaleValue;
        object.scaleY = object.scaleY * scaleValue;
        object.left = object.left * scaleValue;
        object.top = object.top * scaleValue;

        object.setCoords();
    });
        
    floorCanvas.renderAll();
}

function getScaledCellCoordinates(left, top)
{
    var squaredCoordinates = {};
    squaredCoordinates.left = Math.round(left / scaledGridStep) * scaledGridStep;
    squaredCoordinates.top = Math.round(top / scaledGridStep) * scaledGridStep;
    return squaredCoordinates;
}

initFloorCanvas();

</script>
</html>
<html>
<head>
	<script src="fabric.js"></script>
	<script src="jquery.js"></script>
    <script src="underscore-min.js"></script>
	<style>
canvas {
    border: 1px solid #ccc;
}
</style>
</head>
<body>
	<button id="btnZoomIn">ZoomIn</button> 
	<button id="btnZoomOut">ZoomOut</button> 
	<button id="btnResetZoom">Reset Zoom</button>
    <button id="btnShow">Toggle Show/Hide</button>
	<br/>
	<canvas id="floorDemoCanvas" width="800" height="800"></canvas>
</body>

<script>

function FloorCanvasMap()
{
    var self = this;
    self.scaledGridStep = GRID_STEP_GRANULARITY = 10;
    self.DEFAULT_MAX_PINS_ALLOWED = 1000;
    self.GRID_DIMENSIONS = 800;
    self.scaleFactorApplied = 1;
    self.currentCanvasScale = 1;
    self.SCALE_MULTIPLYING_FACTOR = 1.2;
    self.floorCanvas;
    self.maxPinsAllowed = 3;
    self.rectanglesCount = 0;
    self.selectedPin;
    self.selectedOldScaleX;
    self.selectedOldScaleY;

    self.reportingMode = false;

    self.COLOR_CATEGORY_1 = '#00FF00';
    self.COLOR_CATEGORY_2 = '#FF00FF';
    self.COLOR_CATEGORY_3 = 'red';

    self.arrayOfPins = [];
}

FloorCanvasMap.prototype.init = function(usedForReporting)
{
    var self = this;

    self.reportingMode = usedForReporting;

    if (!self.reportingMode)
    {
        self.maxPinsAllowed = 1;
    }
    else
    {
        self.maxPinsAllowed = self.DEFAULT_MAX_PINS_ALLOWED;
    }

    self.floorCanvas = new fabric.Canvas('floorDemoCanvas', { selection: false });

    fabric.Image.fromURL('floor1.png', function(img) {
          
          // the image should react as a background image
          // it is added as an object so that it can get scaled when zoomed in
          img.hasControls = false;
          img.lockMovementX = true;
          img.lockMovementY = true;

          self.floorCanvas.add(img);

          if (self.reportingMode)
          {
            // cannot add new pins, they are restored from DB
            self.addPinOnGrid(629.9999999999999,80);
          }

          // everything else needs to be added AFTER IMAGE else not visible

        // create grid
        var linesCount = self.GRID_DIMENSIONS / self.GRID_STEP_GRANULARITY;

        for (var lineIndex = 0; lineIndex < linesCount; lineIndex++) {

          self.floorCanvas.add(new fabric.Line([ lineIndex * self.GRID_STEP_GRANULARITY, 0, lineIndex * self.GRID_STEP_GRANULARITY, self.GRID_DIMENSIONS], { stroke: '#ccc', selectable: false }));

          self.floorCanvas.add(new fabric.Line([ 0, lineIndex * self.GRID_STEP_GRANULARITY, self.GRID_DIMENSIONS, lineIndex * self.GRID_STEP_GRANULARITY], { stroke: '#ccc', selectable: false }))
        }
    });

    // snap to grid
    self.floorCanvas.on('object:moving', function(options) {
        var gridFittedCoordinates = self.getScaledCellCoordinates(options.target.left, options.target.top);

        if (gridFittedCoordinates.left < 0)
        {
            gridFittedCoordinates.left = 0;
        }

        if (gridFittedCoordinates.top < 0)
        {
            gridFittedCoordinates.top = 0;
        }

        if ((gridFittedCoordinates.left + self.scaledGridStep) >= self.floorCanvas.width)
        {
            gridFittedCoordinates.left = self.floorCanvas.width - self.scaledGridStep;
        }

        if ((gridFittedCoordinates.top + self.scaledGridStep) >= self.floorCanvas.height)
        {
            gridFittedCoordinates.top = self.floorCanvas.height - self.scaledGridStep;
        }
    
        options.target.set({
            left: gridFittedCoordinates.left,
            top: gridFittedCoordinates.top
        });

        // these are the coordinates that will be saved
        console.log(['pin ', self.getPinId(options.target), ' has been dragged to a new location at [', options.target.left/self.currentCanvasScale, ',', options.target.top/self.currentCanvasScale, '].'].join(''));
    });

    self.floorCanvas.on('object:selected', function(options) {
        if (self.reportingMode)
        {
            // either other pin selected or selection cleared
            // selection:cleared will not happen because floor map will get selected
            self.resetSelectedPin();

            if (options.target.type === "rect")
            {
                self.selectedPin = options.target;
                self.selectedOldScaleX = self.selectedPin.scaleX;
                self.selectedOldScaleY = self.selectedPin.scaleY;
                self.selectedPin.scaleX = 2;
                self.selectedPin.scaleY = 2;
                self.selectedPin.borderColor = 'blue';
            }
        }
    });

    self.floorCanvas.on('mouse:down', function(options) {
        var cellClickedLeft = Math.trunc(options.e.layerX / self.scaledGridStep) * self.scaledGridStep;
        var cellClickedTop = Math.trunc(options.e.layerY / self.scaledGridStep) * self.scaledGridStep;

        var objectsToDrag = self.getObjectsWithinCell(cellClickedLeft, cellClickedTop);
        var noObjectToDrag = (objectsToDrag.length === 0);
        if (noObjectToDrag)
        {
            if (!self.reportingMode)
            {
                if (self.rectanglesCount < self.maxPinsAllowed)
                {
                    self.addPinOnGrid(cellClickedLeft, cellClickedTop);
                }
                else
                {
                    console.log('Max amount of pins allowed was reached');
                }
            }
        }
        else
        {
            self.changePinColor(objectsToDrag[0], self.COLOR_CATEGORY_3);
        }
    });

    $("#btnZoomIn").click(function(){
        self.zoomIn();
    });

    $("#btnZoomOut").click(function(){
        self.zoomOut();
    });

    $("#btnResetZoom").click(function(){
        self.resetZoom();
    });

    $("#btnShow").click(function(){
        _.each(self.arrayOfPins, function(pin){
            pin.canvasPin.visible = !pin.canvasPin.visible;
        });

        self.floorCanvas.renderAll();
    });
}

FloorCanvasMap.prototype.changePinColor = function(pin, color)
{
    var self = this;
    pin.fill = color;
    self.floorCanvas.renderAll();

    console.log(['pin ', self.getPinId(pin), ' has changed color.'].join(''));
}

FloorCanvasMap.prototype.getPinId = function(pinObject)
{
    var self = this;

    var pinId;

    var pinFound = _.filter(self.arrayOfPins, function(entry){
        return entry.canvasPin === pinObject;
    });

    if (pinFound.length > 0)
    {
        pinId = pinFound[0].id;
    }

    return pinId;
}

FloorCanvasMap.prototype.addPinOnGrid = function(left, top)
{
    var self = this;

    var pin = new fabric.Rect({ 
        left: left, 
        top: top, 
        width: self.scaledGridStep, 
        height: self.scaledGridStep, 
        fill: self.COLOR_CATEGORY_1, 
        originX: 'left', 
        originY: 'top',
        hasControls: false//,
        //angle: 45
    });

    self.floorCanvas.add(pin);
    self.rectanglesCount++;

    self.arrayOfPins.push({id: self.rectanglesCount, canvasPin: pin});

    console.log(['new pin ', self.rectanglesCount ,' created at [', left, ',', top, ']'].join(''));
}

FloorCanvasMap.prototype.resetSelectedPin = function()
{
    var self = this;
    console.log('selection cleared');

    if (self.selectedPin != null)
    {
        self.selectedPin.scaleX = self.selectedOldScaleX;
        self.selectedPin.scaleY = self.selectedOldScaleY;
        self.selectedPin = null;
        self.selectedOldScaleX = null;
        self.selectedOldScaleY = null;
    }
}

FloorCanvasMap.prototype.zoomIn = function() {
    var self = this;
    self.applyScaleToGridAndObjects(self.SCALE_MULTIPLYING_FACTOR);
}

FloorCanvasMap.prototype.zoomOut = function() {
    var self = this;
    self.applyScaleToGridAndObjects(1/self.SCALE_MULTIPLYING_FACTOR);  
}

FloorCanvasMap.prototype.resetZoom = function() {
    var self = this;
    self.applyScaleToGridAndObjects(1/self.currentCanvasScale);

    self.currentCanvasScale = 1;
    self.scaleFactorApplied = 1;
}

FloorCanvasMap.prototype.applyScaleToGridAndObjects = function(scaleValue)
{
    var self = this;
    self.scaleFactorApplied = scaleValue;
    self.currentCanvasScale = self.currentCanvasScale * scaleValue;
    console.log('current canvas scale is '+ self.currentCanvasScale);
    self.scaledGridStep = self.scaledGridStep * scaleValue;
    console.log('current grid cell scaled is '+ self.scaledGridStep);

    self.floorCanvas.setHeight(self.floorCanvas.getHeight() * scaleValue);
    self.floorCanvas.setWidth(self.floorCanvas.getWidth() * scaleValue);
    
    var objectsOnCanvas = self.floorCanvas.getObjects();

    _.each(objectsOnCanvas, function(object){

        object.scaleX = object.scaleX * scaleValue;
        object.scaleY = object.scaleY * scaleValue;
        object.left = object.left * scaleValue;
        object.top = object.top * scaleValue;

        object.setCoords();
    });
        
    self.floorCanvas.renderAll();
}

FloorCanvasMap.prototype.getScaledCellCoordinates = function(left, top)
{
    var self = this;
    var squaredCoordinates = {};
    squaredCoordinates.left = Math.round(left / self.scaledGridStep) * self.scaledGridStep;
    squaredCoordinates.top = Math.round(top / self.scaledGridStep) * self.scaledGridStep;
    return squaredCoordinates;
}

FloorCanvasMap.prototype.getObjectsWithinCell = function(left, top)
{
    var self = this;
    var objectsOnCanvas = self.floorCanvas.getObjects();

    // because we're working on a grid, no need to use a rectangle to find existing objects
    var objectsWithinCell = _.filter(objectsOnCanvas, function(object){
        return object.left === left && object.top === top;
    });

    return objectsWithinCell;
}

var map = new FloorCanvasMap();
map.init(true);

</script>
</html>
<html>
<head>
	<script src="fabric.js"></script>
	<script src="jquery.js"></script>
    <script src="underscore-min.js"></script>
	<style>
canvas {
    border: 1px solid #ccc;
}
</style>
</head>
<body>
	<button id="btnZoomIn">ZoomIn</button> 
	<button id="btnZoomOut">ZoomOut</button> 
	<button id="btnResetZoom">Reset Zoom</button>
	<br/>
	<canvas id="floorDemoCanvas" width="800" height="800"></canvas>
</body>

<script>
var GRID_STEP_GRANULARITY = 25;
var scaledGridStep = 25;
var GRID_DIMENSIONS = 800;
var scaleFactorApplied = 1;
var currentCanvasScale = 1;
var SCALE_MULTIPLYING_FACTOR = 1.2;
var floorCanvas;
var MAX_RECTANGLES_ALLOWED = 3;
var rectanglesCount = 0;

var COLOR_CATEGORY_1 = '#faa';
var COLOR_CATEGORY_2 = '#ert';
var COLOR_CATEGORY_3 = '#ccc';

function initFloorCanvas()
{
    floorCanvas = new fabric.Canvas('floorDemoCanvas', { selection: false });

    fabric.Image.fromURL('floor.png', function(img) {
          
          // the image should react as a background image
          // it is added as an object so that it can get scaled when zoomed in
          img.hasControls = false;
          img.lockMovementX = true;
          img.lockMovementY = true;

          floorCanvas.add(img);

          // everything else needs to be added AFTER IMAGE else not visible

        // create grid
        var linesCount = GRID_DIMENSIONS / GRID_STEP_GRANULARITY;

        for (var lineIndex = 0; lineIndex < linesCount; lineIndex++) {

          floorCanvas.add(new fabric.Line([ lineIndex * GRID_STEP_GRANULARITY, 0, lineIndex * GRID_STEP_GRANULARITY, GRID_DIMENSIONS], { stroke: '#ccc', selectable: false }));

          floorCanvas.add(new fabric.Line([ 0, lineIndex * GRID_STEP_GRANULARITY, GRID_DIMENSIONS, lineIndex * GRID_STEP_GRANULARITY], { stroke: '#ccc', selectable: false }))
        }
    });

    // snap to grid
    floorCanvas.on('object:moving', function(options) {
        var gridFittedCoordinates = getScaledCellCoordinates(options.target.left, options.target.top);

        if (gridFittedCoordinates.left < 0)
        {
            gridFittedCoordinates.left = 0;
        }

        if (gridFittedCoordinates.top < 0)
        {
            gridFittedCoordinates.top = 0;
        }

        if ((gridFittedCoordinates.left + scaledGridStep) >= floorCanvas.width)
        {
            gridFittedCoordinates.left = floorCanvas.width - scaledGridStep;
        }

        if ((gridFittedCoordinates.top + scaledGridStep) >= floorCanvas.height)
        {
            gridFittedCoordinates.top = floorCanvas.height - scaledGridStep;
        }
    
        options.target.set({
            left: gridFittedCoordinates.left,
            top: gridFittedCoordinates.top
        });
    });

    floorCanvas.on('mouse:down', function(options) {

        var cellClickedLeft = Math.trunc(options.e.layerX / scaledGridStep) * scaledGridStep;
        var cellClickedTop = Math.trunc(options.e.layerY / scaledGridStep) * scaledGridStep;

        var objectsToDrag = getObjectsWithinCell(cellClickedLeft, cellClickedTop);
        var noObjectToDrag = (objectsToDrag.length === 0);
        if (noObjectToDrag)
        {
            if (rectanglesCount < MAX_RECTANGLES_ALLOWED)
            {
                addPinOnGrid(cellClickedLeft, cellClickedTop);
            }
            else
            {
                console.log('Max amount of pins allowed was reached');
            }
        }
        else
        {
            changePinColor(objectsToDrag[0], COLOR_CATEGORY_3);
        }
    });

    function changePinColor(pin, color)
    {
        pin.fill = color;
        floorCanvas.renderAll();
    }

    function addPinOnGrid(left, top)
    {
        floorCanvas.add(new fabric.Rect({ 
            left: left, 
            top: top, 
            width: scaledGridStep, 
            height: scaledGridStep, 
            fill: COLOR_CATEGORY_1, 
            originX: 'left', 
            originY: 'top',
            hasControls: false
        }));
        rectanglesCount++;

        console.log(['new pin created at [', left, ',', top, ']'].join(''));
    }

    $("#btnZoomIn").click(function(){
        zoomIn();
    });

    $("#btnZoomOut").click(function(){
        zoomOut();
    });

    $("#btnResetZoom").click(function(){
        resetZoom();
    });
}

function zoomIn() {
    applyScaleToGridAndObjects(SCALE_MULTIPLYING_FACTOR);
}

function zoomOut() {
    applyScaleToGridAndObjects(1/SCALE_MULTIPLYING_FACTOR);  
}

function resetZoom() {
    applyScaleToGridAndObjects(1/currentCanvasScale);

    currentCanvasScale = 1;
    scaleFactorApplied = 1;
}

function applyScaleToGridAndObjects(scaleValue)
{
    scaleFactorApplied = scaleValue;
    currentCanvasScale = currentCanvasScale * scaleValue;
    scaledGridStep = scaledGridStep * scaleValue;

    floorCanvas.setHeight(floorCanvas.getHeight() * scaleValue);
    floorCanvas.setWidth(floorCanvas.getWidth() * scaleValue);
    
    var objectsOnCanvas = floorCanvas.getObjects();

    _.each(objectsOnCanvas, function(object){

        object.scaleX = object.scaleX * scaleValue;
        object.scaleY = object.scaleY * scaleValue;
        object.left = object.left * scaleValue;
        object.top = object.top * scaleValue;

        object.setCoords();
    });
        
    floorCanvas.renderAll();
}

function getScaledCellCoordinates(left, top)
{
    var squaredCoordinates = {};
    squaredCoordinates.left = Math.round(left / scaledGridStep) * scaledGridStep;
    squaredCoordinates.top = Math.round(top / scaledGridStep) * scaledGridStep;
    return squaredCoordinates;
}

function getObjectsWithinCell(left, top)
{
    var objectsOnCanvas = floorCanvas.getObjects();

    // because we're working on a grid, no need to use a rectangle to find existing objects
    var objectsWithinCell = _.filter(objectsOnCanvas, function(object){
        return object.left === left && object.top === top;
    });

    return objectsWithinCell;
}

initFloorCanvas();

</script>
</html>
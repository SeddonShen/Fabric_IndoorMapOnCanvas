<html>
<head>
	<script src="fabric.js"></script>
	<script src="jquery.js"></script>
    <script src="underscore-min.js"></script>
	<style>
canvas {
    border: 1px solid #ccc;
}
</style>
</head>
<body>
	<button id="btnZoomIn">ZoomIn</button> 
	<button id="btnZoomOut">ZoomOut</button> 
	<button id="btnResetZoom">Reset Zoom</button>
    <button id="btnShow">Toggle Show/Hide</button>
	<br/>
	<canvas id="floorDemoCanvas" width="800" height="800"></canvas>
</body>

<script>
var scaledGridStep = GRID_STEP_GRANULARITY = 10;
var DEFAULT_MAX_PINS_ALLOWED = 1000;
var GRID_DIMENSIONS = 800;
var scaleFactorApplied = 1;
var currentCanvasScale = 1;
var SCALE_MULTIPLYING_FACTOR = 1.2;
var floorCanvas;
var maxPinsAllowed = 3;
var rectanglesCount = 0;
var selectedPin;
var selectedOldScaleX;
var selectedOldScaleY;

var isReportingMode = false;

var COLOR_CATEGORY_1 = '#00FF00';
var COLOR_CATEGORY_2 = '#FF00FF';
var COLOR_CATEGORY_3 = 'red';

var arrayOfPins = [];

function initFloorCanvas(usedForReporting)
{
    isReportingMode = usedForReporting;

    if (!isReportingMode)
    {
        maxPinsAllowed = 1;
    }
    else
    {
        maxPinsAllowed = DEFAULT_MAX_PINS_ALLOWED;
    }

    floorCanvas = new fabric.Canvas('floorDemoCanvas', { selection: false });

    fabric.Image.fromURL('floor1.png', function(img) {
          
          // the image should react as a background image
          // it is added as an object so that it can get scaled when zoomed in
          img.hasControls = false;
          img.lockMovementX = true;
          img.lockMovementY = true;

          floorCanvas.add(img);

          if (isReportingMode)
          {
            // cannot add new pins, they are restored from DB
            addPinOnGrid(scaledGridStep,scaledGridStep);
          }

          // everything else needs to be added AFTER IMAGE else not visible

        // create grid
        // var linesCount = GRID_DIMENSIONS / GRID_STEP_GRANULARITY;

        // for (var lineIndex = 0; lineIndex < linesCount; lineIndex++) {

        //   floorCanvas.add(new fabric.Line([ lineIndex * GRID_STEP_GRANULARITY, 0, lineIndex * GRID_STEP_GRANULARITY, GRID_DIMENSIONS], { stroke: '#ccc', selectable: false }));

        //   floorCanvas.add(new fabric.Line([ 0, lineIndex * GRID_STEP_GRANULARITY, GRID_DIMENSIONS, lineIndex * GRID_STEP_GRANULARITY], { stroke: '#ccc', selectable: false }))
        // }
    });

    // snap to grid
    floorCanvas.on('object:moving', function(options) {
        var gridFittedCoordinates = getScaledCellCoordinates(options.target.left, options.target.top);

        if (gridFittedCoordinates.left < 0)
        {
            gridFittedCoordinates.left = 0;
        }

        if (gridFittedCoordinates.top < 0)
        {
            gridFittedCoordinates.top = 0;
        }

        if ((gridFittedCoordinates.left + scaledGridStep) >= floorCanvas.width)
        {
            gridFittedCoordinates.left = floorCanvas.width - scaledGridStep;
        }

        if ((gridFittedCoordinates.top + scaledGridStep) >= floorCanvas.height)
        {
            gridFittedCoordinates.top = floorCanvas.height - scaledGridStep;
        }
    
        options.target.set({
            left: gridFittedCoordinates.left,
            top: gridFittedCoordinates.top
        });

        console.log(['pin ', getPinId(options.target), ' has been dragged to a new location at [', gridFittedCoordinates.left, ',', gridFittedCoordinates.top, '].'].join(''));
    });

    floorCanvas.on('object:selected', function(options) {
        if (isReportingMode)
        {
            // either other pin selected or selection cleared
            // selection:cleared will not happen because floor map will get selected
            resetSelectedPin();

            if (options.target.type === "rect")
            {

                selectedPin = options.target;
                selectedOldScaleX = selectedPin.scaleX;
                selectedOldScaleY = selectedPin.scaleY;
                selectedPin.scaleX = 2;
                selectedPin.scaleY = 2;
                selectedPin.borderColor = 'blue';
            }
        }
    });

    function resetSelectedPin()
    {
        console.log('selection cleared');
        if (selectedPin != null)
        {
            selectedPin.scaleX = selectedOldScaleX;
            selectedPin.scaleY = selectedOldScaleY;
            selectedPin = null;
            selectedOldScaleX = null;
            selectedOldScaleY = null;
        }
    }

    floorCanvas.on('mouse:down', function(options) {
        var cellClickedLeft = Math.trunc(options.e.layerX / scaledGridStep) * scaledGridStep;
        var cellClickedTop = Math.trunc(options.e.layerY / scaledGridStep) * scaledGridStep;

        var objectsToDrag = getObjectsWithinCell(cellClickedLeft, cellClickedTop);
        var noObjectToDrag = (objectsToDrag.length === 0);
        if (noObjectToDrag)
        {
            if (!isReportingMode)
            {
                if (rectanglesCount < maxPinsAllowed)
                {
                    addPinOnGrid(cellClickedLeft, cellClickedTop);
                }
                else
                {
                    console.log('Max amount of pins allowed was reached');
                }
            }
        }
        else
        {
            changePinColor(objectsToDrag[0], COLOR_CATEGORY_3);
        }
    });

    function changePinColor(pin, color)
    {
        pin.fill = color;
        floorCanvas.renderAll();

        console.log(['pin ', getPinId(pin), ' has changed color.'].join(''));
    }

    function getPinId(pinObject)
    {
        var pinId;

        var pinFound = _.filter(arrayOfPins, function(entry){
            return entry.canvasPin === pinObject;
        });

        if (pinFound.length > 0)
        {
            pinId = pinFound[0].id;
        }

        return pinId;
    }

    function addPinOnGrid(left, top)
    {
        var pin = new fabric.Rect({ 
            left: left, 
            top: top, 
            width: scaledGridStep, 
            height: scaledGridStep, 
            fill: COLOR_CATEGORY_1, 
            originX: 'left', 
            originY: 'top',
            hasControls: false,
            angle: 45
        });

        floorCanvas.add(pin);
        rectanglesCount++;

        arrayOfPins.push({id: rectanglesCount, canvasPin: pin});

        console.log(['new pin ', rectanglesCount ,' created at [', left, ',', top, ']'].join(''));
    }

    $("#btnZoomIn").click(function(){
        zoomIn();
    });

    $("#btnZoomOut").click(function(){
        zoomOut();
    });

    $("#btnResetZoom").click(function(){
        resetZoom();
    });

    $("#btnShow").click(function(){
        _.each(arrayOfPins, function(pin){
            pin.canvasPin.visible = !pin.canvasPin.visible;
        });

        floorCanvas.renderAll();
    });
}

function zoomIn() {
    applyScaleToGridAndObjects(SCALE_MULTIPLYING_FACTOR);
}

function zoomOut() {
    applyScaleToGridAndObjects(1/SCALE_MULTIPLYING_FACTOR);  
}

function resetZoom() {
    applyScaleToGridAndObjects(1/currentCanvasScale);

    currentCanvasScale = 1;
    scaleFactorApplied = 1;
}

function applyScaleToGridAndObjects(scaleValue)
{
    scaleFactorApplied = scaleValue;
    currentCanvasScale = currentCanvasScale * scaleValue;
    scaledGridStep = scaledGridStep * scaleValue;

    floorCanvas.setHeight(floorCanvas.getHeight() * scaleValue);
    floorCanvas.setWidth(floorCanvas.getWidth() * scaleValue);
    
    var objectsOnCanvas = floorCanvas.getObjects();

    _.each(objectsOnCanvas, function(object){

        object.scaleX = object.scaleX * scaleValue;
        object.scaleY = object.scaleY * scaleValue;
        object.left = object.left * scaleValue;
        object.top = object.top * scaleValue;

        object.setCoords();
    });
        
    floorCanvas.renderAll();
}

function getScaledCellCoordinates(left, top)
{
    var squaredCoordinates = {};
    squaredCoordinates.left = Math.round(left / scaledGridStep) * scaledGridStep;
    squaredCoordinates.top = Math.round(top / scaledGridStep) * scaledGridStep;
    return squaredCoordinates;
}

function getObjectsWithinCell(left, top)
{
    var objectsOnCanvas = floorCanvas.getObjects();

    // because we're working on a grid, no need to use a rectangle to find existing objects
    var objectsWithinCell = _.filter(objectsOnCanvas, function(object){
        return object.left === left && object.top === top;
    });

    return objectsWithinCell;
}

initFloorCanvas(true);

</script>
</html>